%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%           Auteur :  P.TRAN BA, E.BOUTTIER, J.SHI, E.ABIA         %
%         Création :  18/01/2012 17:05                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper,11pt]{article}

%\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}
%\usepackage{xunicode}
\usepackage{fontspec}
\defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
\usepackage{a4wide}
\usepackage{verbatim}
\usepackage{polyglossia}
\setdefaultlanguage{french}
%~ \usepackage{listings}
%\usepackage[french]{babel}
%~ \usepackage{url}
%~ \usepackage{times}
\usepackage{minted}
\usepackage{amssymb}
\usepackage{graphicx}
\input{graphviz}

\usepackage{geometry}
\geometry{hmargin=2.5cm,vmargin=1.5cm}

\title{Projet C\\Simulation d'un commutateur de niveau 3\\Rapport}
\author{Philippe \textsc{Tran Ba}, Élie \textsc{Bouttier}, Jiajun \textsc{Shi}, Émilie \textsc{Abia}\\Groupe 15}
\date\today

\begin{document}

\maketitle

\begin{abstract}

Ce rapport porte sur un projet de programmation d'un commutateur de niveau 3 en langage C. Il y est abordé le fonctionnement global du programme, suivi des choix techniques effectués afin de palier aux problèmes rencontrés. Il termine par une conclusion sur l'état du projet et des améliorations qui pourraient y être apportées.

\end{abstract}

\tableofcontents

\newpage

\section{Introduction}
\subsection{Préface}

Dans le cadre de notre préparation au diplôme d'ingénieur en Télécommunications et Réseaux, nous avons été amenés à effectuer notre projet de première année sous l'encadrement de Jérôme Ermont. Le but de ce projet était surtout de nous faire manipuler le langage C et la gestion de la mémoire mais il nous a également permis de modéliser une solution réseau simple.

La commutation de paquets, technique utilisée dans le transfert de données dans les réseaux informatiques, permet de rediriger les packets sur un lien physique particulier suivant des critères précis, avec éventuellement une modification de ceux-ci. Au vue de notre formation, le choix de la réalisation d'un simulateur de commutateur se trouve être pertinent et intéressant.

Ce rapport est composé de deux parties. La première partie présente l'application dans sa globalité, son fonctionnement. La seconde partie est consacrée au détail de l'implémentation. Enfin nous conclurons sur les apports personnels obtenus à la fin de ce projet.

\subsection{Rappel du sujet}

Nous avons effectué notre projet langage C de première année sous l'encadrement de Jérôme Ermont. Il était question principalement de simuler le fonctionnement d'un commutateur de niveau 3. 

Ainsi il s'agissait dans ce projet de simuler le travail d'un élément réseau dont le rôle serait de recevoir des trames, de les assembler pour reformer des paquets et d'effectuer par la suite la commutation de ces paquets. Les paquets routés sont à nouveau fragmentés et les trames obtenues sont stockées dans des queues selon leur priorité.

La première étape a été l'étude préalable de l'élément réseau impliqué, il s'agissait d'assimiler les fonctionnalités attendues de celui-ci et de, relativement à notre compréhension du sujet, réfléchir à un algorithme.

Dans un second temps, après nous être mis d'accord sur le modèle retenu nous nous sommes départagé le travail afin de gagner du temps.  

Nous avons ensuite regroupé notre travail et avons modifié la structure générale afin de l'optimiser au maximum. 

Enfin, il faut remarquer que cette application peut encore évoluer : il serait par exemple souhaitable que le commutateur soit capable de mieux traiter les erreur (reprise sur erreur, renvoie...)

\section{Implémentation}
\subsection{Architecture de l'application en module}

A la vue des fonctionnalités énoncées ci-dessus, notre solution a été conçue pour être évolutive (car décomposée en modules distinct) et stable. L'application exécutable se décompose en modules fonctionnels explicités par le schéma ci-dessous :

\includegraphics{s1.png}

\subsection{Détail des types et sous programmes}

\begin{center}
\begin{tabular}{|l|l|l|}\hline
MODULE & TYPES & SOUS-PROGRAMMES\\\hline
trame & Trame & trame\_init\\
 &  & trame\_destroy\\
 &  & trame\_decode\\
 &  & trame\_encode\\
 &  & trame\_print\\\hline
packet & Packet & packet\_init\\
 &  & packet\_destroy\\
 &  & packet\_assemble\\
 &  & packet\_split\\
 &  & packet\_print\\\hline
packetfrag & PacketFrag & lpf\_init\\
 &  & lpf\_add\\
 &  & lpf\_del\\
 &  & lpf\_destroy\\
 &  & lpf\_print\\\hline
ListPacketFrag & ListPacketFrag & A faire \\\hline %TODO
queue & Queue WRRS & wrrs\_init\\
 &  & wrrs\_push\\
 &  & wrrs\_pop\\
 &  & wrrs \_print\\\hline
commut & ListRule & commut \_init\\
 &  & commut \_load\\
 &  & commut \_commut\\
 &  & commut \_print\\\hline
simulator & $\varnothing$ & simulate\\\hline
\end{tabular}
\end{center}

\subsection{Présentation des principaux algorithmes}

%TODO

\section{Réalisation du projet}

\subsection{Difficultés et solutions}

Au départ, le stockage dans l'ordre des trames semblait bien difficile. Un tableau dynamique n'était pas simple à manipuler mais nous ne pouvions pas mettre de tableau fixe. Nous avons réalisé que lorsque l'on recevait une trame, on savait directement le nombre de trame que l'on recevrait grâce à l’attribut nbf. Ainsi il semblait bien plus simple d'allouer directement un tableau de la bonne taille et ranger les trames dans le bon ordre.

\subsubsection{Solutions envisageable}

Plusieurs solutions ont été proposées lors de l'étude du cahier des charges. Dans la mesure où il nous était demandé de ne pas nous focaliser sur les performances mais plutôt sur le choix des structures de données et l'efficacité des algorithmes.

Au départ nous comptions gérer les trames dans une partie décodage, gérer les paquets dans une partie assemblage et gérer la queue dans une partie éponyme.
 
Dans la partie décodage nous avions défini une structure de données Trame, une liste chaînée de trames utilisée pour stocker les trames d'un même paquet qui n'est pas encore complet et une liste de « Paquets Fragmentés » ListePacketFrag utilisée pour stocker les différentes listes de trame.


Nous avions alors envisagé que les opérations disponibles sur une trame pourraient être :
Créer une trame à partir d'un numéro de paquet, d'un numéro de séquence, d'un nombre de séquence, de la longueur d'une charge, d'une somme de contrôle et d'un contenu.
\begin{enumerate}
 \item Initialiser une trame
 \item Transformer une séquence de bits en trame
 \item Transformer une trame en une séquence de bits
 \item Vérifier si un ID existe
 \item Ajouter une trame dans la ListeTrame
 \item Ajouter une ListeTrame dans la ListePacketFrag
 \item Vérifier si la ListeTrame est complète
 \item Vérifier si la Trame est correcte en utilisant CRC
 \item Calculer CRC
\end{enumerate}

C'est dans la partie assemblage que nous avions défini la structure Packet et les opérations disponibles sur un paquet, la plus importante étant bien sûr le décodage de la trame dans le but de l'intégrer à un paquet.

Puis dans la partie queue nous avions envisagé que la queue serait un tableau de taille 256, soit le nombre maximal de priorité. 

% TODO

\subsubsection{Difficultés rencontrées}



\subsubsection{Solution retenue}

Ainsi, partant de la volonté de développer une application efficace, nous avons effectué grand nombre de modifications. La plus significative concernant la structure de donnée qui stocke les trames lorsqu'un paquet n'est pas encore complet. En effet, nous sommes passés d'une liste de liste à une liste de tableau.

Un second regard nous a permis de réaliser que lorsque l'on recevait une trame, on savait directement le nombre de trame que l'on recevrait grâce à l’attribut nbf. Ainsi il semblait bien plus simple d'allouer directement un tableau de la bonne taille et ranger les trames dans le bon ordre.

\section{Conclusion}

Pour mener à bien ce projet de première année, nous avons dû approfondir nos connaissances en terme d'analyse de trame. Nous nous sommes aussi documenté sur le fonctionnement des protocoles TCP/IP afin de s'en inspirer.

De plus, ce projet nous a permis de nous familiariser avec la démarche de création d’un programme complexe ainsi  que des notions vues en réseaux. En effet, nous avons développé cette application par un travail de groupe, ce qui nous attend en tant que futurs ingénieurs. Plusieurs personnes travaillant sur un même programme ont besoin d'énormément de coordination et de synchronisation. Cela s'est révélé bien plus difficile que prévu, outre la standardisation de nos variables et la répartition des modules.

La partie que nous avons développée correspond aux objectifs de départ. Les résultats de simulation sont tout à fait satisfaisants tant au niveau routage qu’au niveau gestion de la mémoire. Savoir faire des simulation et le faire tout le long du projet est un outil précieux afin de corriger les erreurs le plus vite possible avant que celles-ci ne se répercutent sur la suite.

Le projet que nous avons réalisé cette année peut encore évoluer. En effet, il subsiste un problème lorsqu'une trame arrive puis une des trames du même paquets n'arrive pas. La trame est gardée. Nous pourrions ajouter un compte à rebours qui détruit la trame si une autre trame du même paquet n'arrive pas.

\end{document}
